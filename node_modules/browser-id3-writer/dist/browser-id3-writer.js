(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ID3Writer"] = factory();
	else
		root["ID3Writer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var encoder = __webpack_require__(1);
	var signatures = __webpack_require__(2);
	
	function uint32ToUint8Array(uint32) {
	    var uint8array = [];
	    var eightBitMask = (1 << 8) - 1;
	
	    for (var i = 24; i >= 0; i -= 8) {
	        uint8array.push(uint32 >>> i & eightBitMask);
	    }
	    return uint8array;
	}
	
	function uint28ToUint7Array(uint28) {
	    var uint7array = [];
	    var sevenBitMask = (1 << 7) - 1;
	
	    for (var i = 21; i >= 0; i -= 7) {
	        uint7array.push(uint28 >>> i & sevenBitMask);
	    }
	    return uint7array;
	}
	
	function uint7ArrayToUint28(uint7Array) {
	    var uint28 = 0;
	
	    for (var i = 0, pow = 21; pow >= 0; pow -= 7, i++) {
	        uint28 += uint7Array[i] << pow;
	    }
	    return uint28;
	}
	
	function artistsToStr(artists) {
	    return artists.join('/') || 'Unknown Artist';
	}
	
	function genresToStr(genres) {
	    // this delimiter works fine in Windows Explorer but nothing said about it in the spec
	    return genres.join(';');
	}
	
	function getTotalFrameSize(frames) {
	    var size = 0;
	
	    frames.forEach(function (frame) {
	        size += frame.size;
	    });
	    return size;
	}
	
	function getNumericFrameSize(frameSize) {
	    var headerSize = 10;
	    var encodingSize = 1;
	
	    return headerSize + encodingSize + frameSize;
	}
	
	function getStringFrameSize(frameSize) {
	    var headerSize = 10;
	    var encodingSize = 1;
	    var bomSize = 2;
	    var frameUtf16Size = frameSize * 2;
	
	    return headerSize + encodingSize + bomSize + frameUtf16Size;
	}
	
	function getLyricsFrameSize(lyricsSize) {
	    var headerSize = 10;
	    var encodingSize = 1;
	    var languageSize = 3;
	    var contentDescriptorSize = 2;
	    var bomSize = 2;
	    var lyricsUtf16Size = lyricsSize * 2;
	
	    return headerSize + encodingSize + languageSize + bomSize + contentDescriptorSize + bomSize + lyricsUtf16Size;
	}
	
	function getPictureFrameSize(frameSize, mimeTypeSize) {
	    var headerSize = 10;
	    var encodingSize = 1;
	    var nullSize = 1;
	    var pictureTypeSize = 1;
	
	    return headerSize + encodingSize + mimeTypeSize + nullSize + pictureTypeSize + nullSize + frameSize;
	}
	
	var Writer = function () {
	    _createClass(Writer, [{
	        key: '_setIntegerFrame',
	        value: function _setIntegerFrame(name, value) {
	            var integer = parseInt(value, 10);
	
	            this.frames.push({
	                name: name,
	                value: integer,
	                size: getNumericFrameSize(integer.toString().length)
	            });
	        }
	    }, {
	        key: '_setStringFrame',
	        value: function _setStringFrame(name, value) {
	            var stringValue = value.toString();
	
	            this.frames.push({
	                name: name,
	                value: stringValue,
	                size: getStringFrameSize(stringValue.length)
	            });
	        }
	    }, {
	        key: '_setPictureFrame',
	        value: function _setPictureFrame(name, buffer) {
	            var mimeType = signatures.getMimeType(new Uint8Array(buffer), 0, 12);
	
	            if (!mimeType) {
	                throw new Error('Unknown picture MIME type');
	            }
	            this.frames.push({
	                name: name,
	                value: buffer,
	                mimeType: mimeType,
	                size: getPictureFrameSize(buffer.byteLength, mimeType.length)
	            });
	        }
	    }, {
	        key: '_setLyricsFrame',
	        value: function _setLyricsFrame(name, lyrics) {
	            var stringValue = lyrics.toString();
	
	            this.frames.push({
	                name: name,
	                value: stringValue,
	                size: getLyricsFrameSize(stringValue.length)
	            });
	        }
	    }]);
	
	    function Writer(buffer) {
	        _classCallCheck(this, Writer);
	
	        if (!buffer || (typeof buffer === 'undefined' ? 'undefined' : _typeof(buffer)) !== 'object' || !('byteLength' in buffer)) {
	            throw new Error('First argument should be an instance of ArrayBuffer or Buffer');
	        }
	
	        this.arrayBuffer = buffer;
	        this.padding = 4096;
	        this.frames = [];
	        this.url = '';
	    }
	
	    _createClass(Writer, [{
	        key: 'setFrame',
	        value: function setFrame(frameName, frameValue) {
	            switch (frameName) {
	                case 'TPE1': // song artists
	                case 'TCOM':
	                    // song composers
	                    {
	                        if (!Array.isArray(frameValue)) {
	                            throw new Error(frameName + ' frame value should be an array of strings');
	                        }
	                        var artists = frameValue.map(function (artist) {
	                            return artist.toString();
	                        });
	                        var artistsStr = artistsToStr(artists);
	
	                        this._setStringFrame(frameName, artistsStr);
	                        break;
	                    }
	                case 'TCON':
	                    // song genre
	                    {
	                        if (!Array.isArray(frameValue)) {
	                            throw new Error(frameName + ' frame value should be an array of strings');
	                        }
	                        var frames = frameValue.map(function (frame) {
	                            return frame.toString();
	                        });
	                        var genresStr = genresToStr(frames);
	
	                        this._setStringFrame(frameName, genresStr);
	                        break;
	                    }
	                case 'TIT2': // song title
	                case 'TALB': // album title
	                case 'TPE2': // album artist // spec doesn't say anything about separator, so it is a string, not array
	                case 'TRCK': // song number in album: 5 or 5/10
	                case 'TPOS': // album disc number: 1 or 1/3
	                case 'TPUB':
	                    // label name
	                    {
	                        this._setStringFrame(frameName, frameValue);
	                        break;
	                    }
	                case 'TLEN': // song duration
	                case 'TYER':
	                    // album release year
	                    {
	                        this._setIntegerFrame(frameName, frameValue);
	                        break;
	                    }
	                case 'USLT':
	                    // unsychronised lyrics
	                    {
	                        this._setLyricsFrame(frameName, frameValue);
	                        break;
	                    }
	                case 'APIC':
	                    // song cover
	                    {
	                        if ((typeof frameValue === 'undefined' ? 'undefined' : _typeof(frameValue)) !== 'object' || !('byteLength' in frameValue)) {
	                            throw new Error('APIC frame value should be an instance of ArrayBuffer or Buffer');
	                        }
	                        this._setPictureFrame(frameName, frameValue);
	                        break;
	                    }
	                default:
	                    {
	                        throw new Error('Unsupported frame ' + frameName);
	                    }
	            }
	            return this;
	        }
	    }, {
	        key: 'removeTag',
	        value: function removeTag() {
	            var headerLength = 10;
	            var bufferLength = this.arrayBuffer.byteLength;
	
	            if (bufferLength < headerLength) {
	                return;
	            }
	            var firstTenBytes = new Uint8Array(this.arrayBuffer, 0, headerLength);
	            var version = firstTenBytes[3];
	            var tagSize = uint7ArrayToUint28([firstTenBytes[6], firstTenBytes[7], firstTenBytes[8], firstTenBytes[9]]) + headerLength;
	
	            if (!signatures.isId3v2(firstTenBytes) || version < 2 || version > 4) {
	                return;
	            }
	
	            this.arrayBuffer = this.arrayBuffer.slice(tagSize);
	        }
	    }, {
	        key: 'addTag',
	        value: function addTag() {
	            this.removeTag();
	
	            var BOM = [0xff, 0xfe];
	            var headerSize = 10;
	            var totalFrameSize = getTotalFrameSize(this.frames);
	            var totalTagSize = headerSize + totalFrameSize + this.padding;
	            var buffer = new ArrayBuffer(this.arrayBuffer.byteLength + totalTagSize);
	            var bufferWriter = new Uint8Array(buffer);
	
	            var offset = 0;
	            var writeBytes = [];
	
	            writeBytes = [0x49, 0x44, 0x33, 3]; // ID3 tag and version
	            bufferWriter.set(writeBytes, offset);
	            offset += writeBytes.length;
	
	            offset++; // version revision
	            offset++; // flags
	
	            writeBytes = uint28ToUint7Array(totalTagSize - headerSize); // tag size (without header)
	            bufferWriter.set(writeBytes, offset);
	            offset += writeBytes.length;
	
	            this.frames.forEach(function (frame) {
	                writeBytes = encoder.encodeUtf8Ascii(frame.name); // frame name
	                bufferWriter.set(writeBytes, offset);
	                offset += writeBytes.length;
	
	                writeBytes = uint32ToUint8Array(frame.size - headerSize); // frame size (without header)
	                bufferWriter.set(writeBytes, offset);
	                offset += writeBytes.length;
	
	                offset += 2; // flags
	
	                switch (frame.name) {
	                    case 'TPE1':
	                    case 'TCOM':
	                    case 'TCON':
	                    case 'TIT2':
	                    case 'TALB':
	                    case 'TPE2':
	                    case 'TRCK':
	                    case 'TPOS':
	                    case 'TPUB':
	                        {
	                            writeBytes = [1].concat(BOM); // encoding, BOM
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	
	                            writeBytes = encoder.encodeUtf16le(frame.value); // frame value
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	                            break;
	                        }
	                    case 'USLT':
	                        {
	                            var langEng = [101, 110, 103];
	
	                            writeBytes = [1].concat(langEng, BOM); // encoding, language, BOM for content descriptor
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	
	                            offset += 2; // content descriptor
	
	                            writeBytes = BOM; // BOM for frame value
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	
	                            writeBytes = encoder.encodeUtf16le(frame.value); // frame value
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	                            break;
	                        }
	                    case 'TLEN':
	                    case 'TYER':
	                        {
	                            offset++; // encoding
	
	                            writeBytes = encoder.encodeUtf8Ascii(frame.value); // frame value
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	                            break;
	                        }
	                    case 'APIC':
	                        {
	                            offset++; // encoding
	
	                            writeBytes = encoder.encodeUtf8Ascii(frame.mimeType); // MIME type
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	
	                            writeBytes = [0, 3, 0]; // delemiter, pic type, delemiter
	                            bufferWriter.set(writeBytes, offset);
	                            offset += writeBytes.length;
	
	                            bufferWriter.set(new Uint8Array(frame.value), offset); // picture content
	                            offset += frame.value.byteLength;
	                            break;
	                        }
	                }
	            });
	
	            offset += this.padding; // free space for rewriting
	            bufferWriter.set(new Uint8Array(this.arrayBuffer), offset);
	            this.arrayBuffer = buffer;
	            return buffer;
	        }
	    }, {
	        key: 'getBlob',
	        value: function getBlob() {
	            return new Blob([this.arrayBuffer], { type: 'audio/mpeg' });
	        }
	    }, {
	        key: 'getURL',
	        value: function getURL() {
	            if (!this.url) {
	                this.url = URL.createObjectURL(this.getBlob());
	            }
	            return this.url;
	        }
	    }, {
	        key: 'revokeURL',
	        value: function revokeURL() {
	            URL.revokeObjectURL(this.url);
	        }
	    }]);
	
	    return Writer;
	}();
	
	module.exports = Writer;

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';
	
	function encodeUtf8Ascii(str) {
	    var codePoints = String(str).split('').map(function (c) {
	        var charCode = c.charCodeAt(0);
	        if (charCode > 0x7F) {
	            throw new Error('Trying to encode not ASCII symbol');
	        }
	        return charCode;
	    });
	
	    return new Uint8Array(codePoints);
	}
	
	function encodeUtf16le(str) {
	    var codePoints = String(str).split('').map(function (c) {
	        return c.charCodeAt(0);
	    });
	    var output = new Uint8Array(str.length * 2);
	
	    new Uint16Array(output.buffer).set(codePoints);
	
	    return output;
	}
	
	module.exports = {
	    encodeUtf8Ascii: encodeUtf8Ascii,
	    encodeUtf16le: encodeUtf16le
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	function isId3v2(buf) {
	    return buf[0] === 0x49 && buf[1] === 0x44 && buf[2] === 0x33;
	}
	
	function getMimeType(buf) {
	    // https://github.com/sindresorhus/file-type
	    if (!buf || !buf.length) {
	        return null;
	    }
	    if (buf[0] === 0xff && buf[1] === 0xd8 && buf[2] === 0xff) {
	        return 'image/jpeg';
	    }
	    if (buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4e && buf[3] === 0x47) {
	        return 'image/png';
	    }
	    if (buf[0] === 0x47 && buf[1] === 0x49 && buf[2] === 0x46) {
	        return 'image/gif';
	    }
	    if (buf[8] === 0x57 && buf[9] === 0x45 && buf[10] === 0x42 && buf[11] === 0x50) {
	        return 'image/webp';
	    }
	    var isLeTiff = buf[0] === 0x49 && buf[1] === 0x49 && buf[2] === 0x2a && buf[3] === 0;
	    var isBeTiff = buf[0] === 0x4d && buf[1] === 0x4d && buf[2] === 0 && buf[3] === 0x2a;
	
	    if (isLeTiff || isBeTiff) {
	        return 'image/tiff';
	    }
	    if (buf[0] === 0x42 && buf[1] === 0x4d) {
	        return 'image/bmp';
	    }
	    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3] === 0) {
	        return 'image/x-icon';
	    }
	    return null;
	}
	
	module.exports = {
	    isId3v2: isId3v2,
	    getMimeType: getMimeType
	};

/***/ }
/******/ ])
});
;
//# sourceMappingURL=browser-id3-writer.js.map